import os
import time
from abc import ABC, abstractmethod

import nvdlib
from openai.lib.azure import AzureOpenAI

from src.model.Singleton import singleton
from src.model.container.mySTIXContainer.AttackPatternsContainer import AttackPatternsContainer
from src.model.gptAPI.gptAPI import GPT_API
from src.model.interfaceToMitre.mitreData.utils.FileUtils import check_exist_file_json, save_to_json_file, \
    read_from_json


class AbstractMitreToVulnerabilityContainer(ABC):
    i = 0
    search_vuln_by_id = None
    MitreToVulnerabilityRetriever = None
    MIN_SIMILARITY = 0.5
    DICT_OF_DOMAINS = {
        "Artificial Intelligence": "atlas",
        "Industrial Control System": "ics",
        "Enterprise": "enterprise",
        "Mobile": "mobile"
    }

    def __init__(self, objects: dict):
        self._objects = objects

    def reset_dataset(self, objects: dict):
        self._objects = objects

    def get_data(self):
        return self._objects

    def get_objects_from_data_by_vuln_id(self, target_id: str):
        """
        This method get the vulnerabilities object by the id
        
        Args: 
            target_id (str): id of the vulnerability
        
        returns:
            searched_obj: list of vulnerability objects
        """
        searched_obj = []
        for obj in self._objects['mapping_objects']:
            if target_id.lower() in obj['capability_id'].lower():
                searched_obj.append(obj)        
        return searched_obj
    
    def get_no_dup_objects_from_data_by_name(self, target_name: str):
        """
        This method get the no duplciate vulnerabilities object by name
        Args:
            target_name (str): The name of the object

        Returns:
            searched_obj: list of vulnerability objects
        """
        return self.__get_no_dup_objects_from_data_by_attr(target_name, 'capability_description')

    def get_no_dup_objects_from_data_by_vuln_id(self, target_id: str):
        """
        This method get the no duplciate vulnerabilities object by id
        Args:
            target_name (str): The name of the object

        Returns:
            searched_obj: list of vulnerability objects
        """
        searched_obj = self.__get_no_dup_objects_from_data_by_attr(target_id, 'capability_id')
        
        # Vuln is not found
        if not searched_obj:
            # NEW MAPPING
            self.__get_related_at_by_new_vuln_id(target_id)
        
        return searched_obj
    
    def __get_no_dup_objects_from_data_by_attr(self, target: str, attr_name: str):
        """
        This method get the no duplciate vulnerabilities object by the attribute name
        Args:
            target_name (str): The name of the objectÃ 
            attr_name (str): The attribute name

        Returns:
            searched_obj: list of vulnerability objects
        """
        searched_obj = []
        
        # if the target is empty return {}
        if not target:
            return {}
        
        for obj in self._objects['mapping_objects']:
            if target.lower() in obj[attr_name].lower():

                # if vuln is not yet in the list (because the same vuln can have multiple mapping)
                searched_obj_in_list_searched = False
                for obj_in_searched_list in searched_obj:
                    # if the same vuln is already founded
                    if obj[attr_name] == obj_in_searched_list[attr_name]:
                        searched_obj_in_list_searched = True

                if not searched_obj_in_list_searched:
                    searched_obj.append(obj)
        
        return searched_obj    

    def get_vuln_id_by_attack_pattern_mitre_id(self, attack_pattern_mitre_id: str) -> list[dict]:
        """
        This method get the list of Vulnerabilty id from releated attack pattern mitre id

        Parameters
        ----------
        attack_pattern_mitre_id : str
            the MITRE ID of the attack pattern

        Returns
        -------
            a list of  {"type of relationship" (ex. primary_impact, secondary_impact, exploitation_technique, uncategorized): vuln_id }
        """
        list_vuln_id = []

        for obj in self._objects['mapping_objects']:
            dict_vuln_id = {}

            # if attack id is found
            if attack_pattern_mitre_id == obj['attack_object_id'] and obj['status'] == 'complete':
                dict_vuln_id[obj["capability_id"]] = [obj["mapping_type"]]

            # if dict is not empty
            if dict_vuln_id:
                list_vuln_id.append(dict_vuln_id)

        return list_vuln_id

    def get_related_at_by_vuln_id(self, target_id: str) -> dict:
        """
        This method get the attack patterns related to a NEW vulnerability and save the mapping
        
        Args:
            target_id (str): id of the vulnerability

        Returns:
            dict_result: dictionary with the attack patterns related to the vulnerability
        """
        
        dict_result = self.__get_related_at_by_vuln_id_in_mapped(target_id)

        # if the vuln is not mapped
        if not dict_result:
            # create the mapping
            dict_result = self.__get_related_at_by_new_vuln_id(target_id)
            
        return dict_result

    def __get_related_at_by_vuln_id_in_mapped(self, target_id: str):
        dict_at_type_rel = {}

        # index to get previous vuln ID to stop the iteration
        for index, obj in enumerate(self._objects['mapping_objects']):
            # if the vuln is found
            if obj["capability_id"] == target_id and obj['status'] == 'complete':
                at = AttackPatternsContainer().get_object_from_data_by_mitre_id(obj['attack_object_id'].strip())

                if obj["mapping_type"] not in dict_at_type_rel:
                    # if there is key
                    dict_at_type_rel[obj["mapping_type"]] = [at]
                else:
                    # if there isn't key, add to the list
                    dict_at_type_rel[obj["mapping_type"]].append(at)

        return dict_at_type_rel

    def __get_related_at_by_new_vuln_id(self, target_id: str) -> dict:
        """
        This method get NEW vulnerability and save the mapping
        
        Args:
            target_id (str): id of the vulnerability

        Returns:
            dict_result: dictionary with the attack patterns related to the vulnerability
        """
        vuln = self.search_vuln_by_id(target_id)

        at_related = []

        # if Vulnerability isn't map in MITRE ENGENUITY use GPT to determinate
        if not dict_result:
            # if cosine similarity is >= 0.5 add attack to related list of attacks

            at_related = self.__get_related_at_from_request(vuln.descriptions[0].value)

            self.i = 0
            dict_result = {'uncategorized': at_related}

            # save new mapping for future research
            self._save_new_mapping(vuln, at_related)

            # update the dataset with new mapping
            self.reset_dataset(self.MitreToVulnerabilityRetriever().get_all_objects())
            
        return dict_result

    def __get_related_at_from_request(self, vuln_desc: str):
        
        domain = GPT_API().get_domain_of_vulnerability(vuln_desc, self.DICT_OF_DOMAINS.keys())

        print(domain)

        time.sleep(60)

        at_related = self.__get_related_at_in_domain_by_vuln_desc(vuln_desc, self.DICT_OF_DOMAINS[domain])

        print(len(at_related))
        print([at.name + " " + at.x_mitre_id for at in at_related])

        return at_related

    def __get_related_at_in_domain_by_vuln_desc(self, vuln_desc: str, domain: str):
        """
        This method search the attack patterns in a certain domain by the vulnerability description
        Args:
            vuln_desc (str): vulnerability description
            domain (str): domain of research

        Returns:
            at_related: list of MyAttackPattern objects
        """

        messages = []

        # Set the message with datasets of certain domain
        for at in [at for at in AttackPatternsContainer().get_tuple_data() if domain in at.x_mitre_domains]:
            json_data = {
                "role": "system",
                "content": "You are a chatbot specializing in the context of cybersecurity, the attack pattern known with the id \'" + at.x_mitre_id + "\' is: " + at.name + ' .'

            }

            messages.append(json_data)

        at_related = [AttackPatternsContainer().get_object_from_data_by_mitre_id(at['id']) for at in GPT_API().get_at_related_from_query(messages, vuln_desc)]

        return at_related

    @abstractmethod
    def _save_new_mapping(self, vulnerability: dict, at_related: list):
        pass
