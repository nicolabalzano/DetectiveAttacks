import time
import re

from src.dataProvider.utils.Singleton import singleton
from src.dataProvider.container.mySTIXContainer.AttackPatternsContainer import AttackPatternsContainer
from src.dataProvider.gptAPI.gptAPI import GPT_API
from src.dataProvider.utils.FileUtils import check_exist_file_json, save_to_json_file, \
    read_from_json
from src.dataProvider.interfaceToCTI.utils.Path import default_path
from src.dataProvider.interfaceToCTI.CTIdata import CAPEC_DATA, MAPPING_EXPLORER_DATA
from src.dataProvider.interfaceToVulnerability.CWE import get_CWE_by_id
from src.dataProvider.interfaceToVulnerability.CVE import get_CVE_by_id

@singleton
class MitreToVulnerabilityContainer():
    i = 0
    __file_name_cwe = 'mapped-cwe'
    __file_name_cve = 'mapped-cve'
    __file_name_capec = 'mapped-capec'

    __DICT_OF_DOMAINS = {
        "Adversarial Machine Learning": "atlas",
        "Industrial Control System": "ics-attack",
        "Enterprise": "enterprise-attack",
        "Mobile": "mobile-attack"
    }
    
    __RELATIONSHIP_SOURCE = {
        "CAPEC": "CAPEC",
        "MAPPING_EXPLORER": "MAPPING_EXPLORER",
        "REQUEST-CWE": "REQUEST-CWE",
        "REQUEST-CVE": "REQUEST-CVE",
        "REQUEST-CAPEC": "REQUEST-CAPEC"
    }


    def __init__(self):
        self.__cwe_data = read_from_json(default_path, self.__file_name_cwe)
        self.__cve_data = read_from_json(default_path, self.__file_name_cve)
        self.__capec_data = read_from_json(default_path, self.__file_name_capec)

    def get_cve_data(self) -> dict :
        return self.__cve_data
    
    
    def get_cwe_data(self)-> dict :
        return self.__cwe_data
    
    
    def get_capec_data(self) -> dict :
        return self.__capec_data
    
    
    def get_vulnerabilities_mapped_data_by_str(self, target_id: str, get_data):
        vulns = []
        for vuln in get_data().keys():
            if target_id.lower() in vuln.lower():
                vulns.append(vuln)
        return vulns
    
    
    def __get_vulnerability_by_id(self, vuln_id: str):
        if vuln_id.startswith('CVE'):
            return get_CVE_by_id(vuln_id)
        elif vuln_id.startswith('CWE'):
            return get_CWE_by_id(vuln_id)
    
    
    def __get_attack_patterns_from_ids(self, dict_mapping):
        new_dict = {}
        for phase, at_ids in dict_mapping.items():
            if phase != "relationship_source":
                new_dict[phase] = [AttackPatternsContainer().get_object_from_data_by_mitre_id(at) for at in at_ids]
        return new_dict
    
    
    def get_related_attack_patterns_by_vulnerability_id(self, vuln_id: str, request_mode: bool = False):
        cwe_ids = set()
        pattern = r"^CWE-\d+$"
        # if the vuln_id is a CVE, we need to search the CWEs related to the CVE
        if vuln_id.startswith('CVE'):
            
            # but if the vuln_id is already mapped in mapped_cve.json, we can get the attack patterns from there
            if vuln_id in self.__cve_data:
                return self.__get_attack_patterns_from_ids(self.__cve_data[vuln_id])
            
            relaitonship_source = self.__RELATIONSHIP_SOURCE["MAPPING_EXPLORER"]
            explotation_techniques, primary_impact, secondary_impact, uncategorized = self.__get_new_mapping_from_MAPPING_EXPORER(vuln_id)
            dict_mapping = self.__format_mapping(relationship_source=relaitonship_source, vuln_id=vuln_id, exploitation_at_ids=explotation_techniques, primary_at_ids=primary_impact, secondary_at_ids=secondary_impact, uncategorized_at_ids=uncategorized)
           
            # else if it's maped in MAPPING EXPLORER return it
            if self.get_list_values_of_dict(dict_mapping):
                self.__save_new_mapping(vuln_id, dict_mapping)
                return self.__get_attack_patterns_from_ids(dict_mapping)
            
            # else search CWEs related to the CVE
            for weakness in self.__get_vulnerability_by_id(vuln_id)['weaknesses']:
                cwe_id = weakness['description'][0]['value']
                if re.match(pattern, cwe_id):
                    cwe_ids.add(cwe_id)
                
        # if the vuln_id is a CWE
        elif vuln_id.startswith('CWE'):
            cwe_ids = set([vuln_id])

        # if there is no CWEs related to the CVE, get the attack patterns id from request
        if not cwe_ids:
            if  request_mode: # not self.get_list_values_of_dict(ats_related) and 
                relaitonship_source = self.__RELATIONSHIP_SOURCE["REQUEST-CVE"]
                at_ids_related = self.__get_related_ats_from_requests_by_vuln_id(vuln_id)
                dict_mapping = self.__format_mapping(relationship_source=relaitonship_source, vuln_id=vuln_id, uncategorized_at_ids=at_ids_related)
                self.__save_new_mapping(vuln_id, dict_mapping)
                return self.__get_attack_patterns_from_ids(dict_mapping)
        
        dict_mapping = self.__get_mapping_of_CWEs(vuln_id, cwe_ids, request_mode)
        
        
        return self.__get_attack_patterns_from_ids(dict_mapping)
    

    def __get_mapping_of_CWEs(self, vuln_id: str, cwe_ids: str, request_mode: bool = False):
        ats_related_collapsed = {"exploitation_techniques": [],
                      "primary_impact": [],
                      "secondary_impact": [],
                      "uncategorized_impact": [],
                      "relationship_source": ""}
        
        for cwe_id in cwe_ids:
            
            # if the vuln_id is mapped in mapped_cwe.json 
            if cwe_id in self.__cwe_data:
                dict_mapping = self.__cwe_data[cwe_id]
                ats_related_collapsed = self.__collapse_dict_values(ats_related_collapsed, dict_mapping)
            else:
                # if there is no mapping in mapped_cwe.json, search the attack patterns in the CAPEC
                dict_mapping = self.__get_new_mapping_from_CAPEC_or_REQUESTS_CWE_CAPEC(cwe_id, request_mode)
                ats_related_collapsed = self.__collapse_dict_values(ats_related_collapsed, dict_mapping)
                # save single mapping CWE
                self.__save_new_mapping(id_=cwe_id, at_ids_related=dict_mapping)
                
        # save the collapsed mapping for vuln_id searched, if the searched vuln is a CVE
        if not vuln_id.startswith('CWE'):                            
            self.__save_new_mapping(id_=vuln_id, at_ids_related=ats_related_collapsed)
        
        return ats_related_collapsed
    

    
    def __get_new_mapping_from_CAPEC_or_REQUESTS_CWE_CAPEC(self, cwe_id: str, request_mode: bool = False):
        relaitonship_source = self.__RELATIONSHIP_SOURCE["CAPEC"]
        
        CAPED_ids = [caped_id['id'] for caped_id in self.__get_vulnerability_by_id(cwe_id)['relatedAttackPatterns']]
        at_ids = set()
        at_ids_related = {}
        check_in_mapped = False
        list_mapping_CAPEC = []

        for CAPEC_id in CAPED_ids:
            # if CAPEC ids are found and is already mapped, update the attack patterns ids dict
            dict_new_mapping = {}
            mapping_founded = []
            if CAPEC_id in self.__capec_data:
                dict_mapping = self.__capec_data[CAPEC_id]
                mapping_founded = dict_mapping['attack_patterns']
                check_in_mapped = True
                at_ids.update(mapping_founded)
                continue
            else:
                check_in_mapped = False
                list_mapping_CAPEC = CAPEC_DATA.get_attack_patterns_mitre_id_by_CAPEC(CAPEC_id)

            # if it's mapped in CAPEC_DATA
            if not check_in_mapped and list_mapping_CAPEC:
                relaitonship_source = self.__RELATIONSHIP_SOURCE["CAPEC"]
                mapping_founded = list_mapping_CAPEC
                dict_new_mapping = self.__format_CAPEC_mapping(relaitonship_source, list_mapping_CAPEC)

            # else if it's not mapped in CAPEC_DATA and the request mode is active, search the attack patterns by the CAPEC description
            elif request_mode:
                relaitonship_source = self.__RELATIONSHIP_SOURCE["REQUEST-CAPEC"]
                CAPEC_desc = CAPEC_DATA.get_capec_by_capec_id(CAPEC_id)['description']
                list_request_CAPEC = self.__get_related_ats_from_requests_by_desc(CAPEC_desc)
                mapping_founded = list_request_CAPEC
                dict_new_mapping = self.__format_CAPEC_mapping(relaitonship_source, list_request_CAPEC)
            
            at_ids.update(mapping_founded)

            # save the single mapping CAPEC
            self.__save_new_mapping(id_=CAPEC_id, at_ids_related=dict_new_mapping)
        
        # if attack pattern ids list is yet empty and the request mode is active, we need to search the attack patterns by the CWE description
        if not at_ids and request_mode:
            relaitonship_source = self.__RELATIONSHIP_SOURCE["REQUEST-CWE"]
            at_ids.update(self.__get_related_ats_from_requests_by_vuln_id(cwe_id))
        
        at_ids_related = self.__format_mapping(relationship_source=relaitonship_source, vuln_id=cwe_id, uncategorized_at_ids=list(at_ids))

        print("-->", cwe_id, at_ids_related)

        return at_ids_related


    def get_list_values_of_dict(self, ats_related: dict) -> list:
        if isinstance(ats_related, list):
            return ats_related
        list_ = [value for sublist in ats_related.values() for value in sublist if isinstance(sublist, list)]
        return list_
    
    def __collapse_dict_values(self, dict_mapping_collapsed: dict, dict_mapping: dict) -> dict:        
        for key in dict_mapping:
            if isinstance(dict_mapping[key], str):
                dict_mapping_collapsed[key] += ' ' + dict_mapping[key]
            else:
                dict_mapping_collapsed[key] += dict_mapping[key]
        return dict_mapping_collapsed
    

    def __format_CAPEC_mapping(self, relationship_source:str, attack_patterns: list) -> dict:
        dict_mapping = {
                "attack_patterns": attack_patterns,
                "relationship_source": relationship_source
                }
        return dict_mapping

    
    def __get_new_mapping_from_MAPPING_EXPORER(self, vuln_id: str):
        dict_mapping = MAPPING_EXPLORER_DATA.get_at_ids_by_cve_id(vuln_id)
        explotation_techniques = dict_mapping["exploitation_technique"] if "exploitation_technique" in dict_mapping else []
        primary_impact = dict_mapping["primary_impact"] if "primary_impact" in dict_mapping else []
        secondary_impact = dict_mapping["secondary_impact"] if "secondary_impact" in dict_mapping else []
        uncategorized = dict_mapping["uncategorized"] if "uncategorized" in dict_mapping else []
        
        return explotation_techniques, primary_impact, secondary_impact, uncategorized
    
    
    def __get_related_ats_from_requests_by_vuln_id(self, vuln_id: str):
        vuln_desc = self.__get_description_from_vuln(vuln_id) 
        return self.__get_related_ats_from_requests_by_desc(vuln_desc)
    
    
    def __get_related_ats_from_requests_by_desc(self, vuln_desc: str):
        
        domain = GPT_API().get_domain_of_description(vuln_desc, self.__DICT_OF_DOMAINS.keys())

        domain = domain.strip('\'"')
        
        at_related = self.__get_related_at_in_domain_by_desc(vuln_desc, self.__DICT_OF_DOMAINS[domain])


        return [at.x_mitre_id for at in at_related]


    def __check_phases_for_mapping(self, phases: str) -> bool:
        """
        This method check if the phases are correct

        Args:
            phases (str): phases of the attack pattern

        Returns:
            bool:  True if the phases are correct, otherwise False
        """
        PHASES_TO_DISCARD = ['reconnaissance']
        
        for phase in phases:
            
            if phase.phase_name.lower() in PHASES_TO_DISCARD:
                return False
        return True
    
    
    def __modify_text(self, text: str) -> str:

        text = re.sub(r'\(.*?\)', '', text.split('\n')[0], flags=re.DOTALL)
        text = re.sub(r'\n\n', '\n', text, flags=re.DOTALL)
        text = re.sub(r'\<.*?\>', '', text, flags=re.DOTALL)
        text = re.sub(r'\[', ' ', text, flags=re.DOTALL)
        text = re.sub(r'\]', ' ', text, flags=re.DOTALL)
        text = re.sub(r'\  ', ' ', text, flags=re.DOTALL)
        text = re.sub(r'\ \.', '.', text, flags=re.DOTALL)
        text = re.sub(r'\ \,', ',', text, flags=re.DOTALL)

        return text
    
    
    def __isSubTechnique(self, at_id: str) -> bool:
        if at_id.startswith('T'):
            if at_id.count('.') == 0:
                return True
            return False
        elif at_id.startswith('AML'):
            if at_id.count('.') == 1:
                return True
            return False
        return False
    
    
    def __get_related_at_in_domain_by_desc(self, vuln_desc: str, domain: str):
        """
        This method search the attack patterns in a certain domain by the vulnerability description
        Args:
            vuln_desc (str): vulnerability description
            domain (str): domain of research

        Returns:
            at_related: list of Attack patterns ids
        """

        messages = [{
            "role": "system",
            "content": "You are a cybersecurity chatbot specializing in identifying and explaining various cybersecurity attack patterns. Below are the ONLY attack patterns of NICOLA you're ONLY familiar with, each described by an ID, name, and description:"
        }]

        counter = 0
        for at in [at for at in AttackPatternsContainer().get_tuple_data() 
                if domain in at.x_mitre_domains 
                and self.__check_phases_for_mapping(at.kill_chain_phases) 
                and self.__isSubTechnique(at.x_mitre_id)
                and not at.revoked
                and not at.x_mitre_deprecated]:
            
            messages[0]["content"] += (
                ' ID:' + at.x_mitre_id + ", name:" + at.name + ', description: ' + self.__modify_text(at.description) + ';'
            )
            counter+=1
            # print(str(counter) + '----> ID:' + at.x_mitre_id + ", name:" + at.name + ', description: ' + self.__modify_text(at.description) + ';')
        
        
        messages[0]["content"] += (
            """ When someone asks you a question: 'What are the attack patterns that match the following description: <description>?'
            you should respond with the exact attack pattern IDs as a JSON object like this: ["ID", "ID", ...].
            For example: ['T1609', 'T1612']. Ensure to find at least one ID that matches the description."""
        )
        ats_related = []
        for at_id in GPT_API().get_at_related_from_query(messages, vuln_desc):
            try:
                at_related = AttackPatternsContainer().get_object_from_data_by_mitre_id(at_id)
                ats_related.append(at_related)
            except:
                at_related = None
                print(f"Attack pattern {at_id} not found")
            
        return ats_related
    
    
    def __format_mapping(self, relationship_source: str, vuln_id: str,  uncategorized_at_ids: list = [], exploitation_at_ids: list = [], primary_at_ids: list = [], secondary_at_ids: list = []):
        dict_mapping ={
                "exploitation_techniques": [],
                "primary_impact": [],
                "secondary_impact": [],
                "uncategorized_impact": [],
                "relationship_source": relationship_source
            }
        if relationship_source not in self.__RELATIONSHIP_SOURCE.values():
            return {}
        
        dict_mapping["exploitation_techniques"] = exploitation_at_ids
        dict_mapping["primary_impact"] = primary_at_ids
        dict_mapping["secondary_impact"] = secondary_at_ids
        dict_mapping["uncategorized_impact"] = uncategorized_at_ids
            
        return dict_mapping
        
    
    def __save_new_mapping(self, id_: str, at_ids_related: dict):
        print(f"Saving new mapping for {id_}, {at_ids_related}")
        if not at_ids_related or not self.get_list_values_of_dict(at_ids_related):
            return None
        dict_to_save = {}
        
        if id_.startswith('CVE'):
            file_name = self.__file_name_cve
            self.__cve_data[id_] = at_ids_related
            dict_to_save = self.__cve_data
        elif id_.startswith('CWE'):
            file_name = self.__file_name_cwe
            self.__cwe_data[id_] = at_ids_related
            dict_to_save = self.__cwe_data
        elif id_.startswith('CAPEC'):
            file_name = self.__file_name_capec
            self.__capec_data[id_] = at_ids_related
            dict_to_save = self.__capec_data
        else:
            return None
        
        
        if not check_exist_file_json(file_name, default_path):
            save_to_json_file({}, file_name, default_path)

        save_to_json_file(dict_to_save, file_name, default_path)
            
    
    def __get_description_from_vuln(self, vuln_id: str) -> str:
        if vuln_id.startswith('CVE'):
            vuln = get_CVE_by_id(vuln_id)['descriptions'][0]['value']
        elif vuln_id.startswith('CWE'):
            vuln = get_CWE_by_id(vuln_id)['short_description']
        return vuln
    