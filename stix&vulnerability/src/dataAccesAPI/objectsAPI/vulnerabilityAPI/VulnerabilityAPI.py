from src.dataAccesAPI.objectsAPI.util import remove_empty_values
from src.dataAccesAPI.objectsAPI.vulnerabilityAPI.CVEAPI import get_CVE_by_id
from src.dataAccesAPI.objectsAPI.vulnerabilityAPI.CWEAPI import get_CWE_by_id
from src.dataProvider.pdfUtility.pdfExtraction.pdfExtraction import check_pdf_for_regular_expressions

import re
import csv

__cve_pattern = re.compile(r"CVE-\d{4}-\d+|CVE ID \d{4}-\d+|CVE ID \d{4} \d+", re.IGNORECASE)
__cwe_pattern = re.compile(r"(CWE-\d+|CWE ID \d+)", re.IGNORECASE)

def get_vulnerability_from_id(id: str):
    """
    This function gets the vulnerability from the id

    Args:
        id (str): id of the vulnerability

    Returns:
        dict: dictionary with the vulnerability info
    """
    if id.startswith('CVE'):
        return get_CVE_by_id(id)    
    elif id.startswith('CWE'):
        return get_CWE_by_id(id)
    else:
        return {}
    
 
def get_vulnerability_in_file(file_path: str):
    """
    This function checks the text for vulnerabilities
    
    Args:
        text (file_path): path to the file
        
    Returns:
        list: list of vulnerabilities
    """
    vulnerabilities = []
    
    if file_path[-4:].lower() == '.pdf': # if the file is a pdf
        vulnerabilities.extend(check_pdf_for_regular_expressions(file_path, __cve_pattern))
        vulnerabilities.extend(check_pdf_for_regular_expressions(file_path, __cwe_pattern))
    elif file_path[-4:].lower() == '.csv': # if the file is a csv
        with open(file_path, mode='r', encoding='utf-8') as file:
            csv_reader = csv.reader(file)
            for row in csv_reader:
                for cell in row:
                    vulnerabilities.extend(__cve_pattern.findall(cell))
                    vulnerabilities.extend(__cwe_pattern.findall(cell))
    else: # if the file is a text file
        with open(file_path, 'r') as file:
            text = file.read()
            vulnerabilities.extend(__cve_pattern.findall(text))
            vulnerabilities.extend(__cwe_pattern.findall(text))
    
    
    vulnerabilities = [v.upper() for v in vulnerabilities if v]
    vulnerabilities = __remove_leading_zeros_and_duplicates_from_vulnerabilities(vulnerabilities)
    
    return list(vulnerabilities)
    
    
def __remove_leading_zeros_and_duplicates_from_vulnerabilities(vulnerabilities):
    """
    This function removes the leading zeros from the vulnerabilities
    
    Args:
        vulnerabilities (list): list of vulnerabilities
        
    Returns:
        list: list of vulnerabilities without leading zeros
    """
    processed_vulnerabilities = set()
    for vulnerability in vulnerabilities:
        parts = re.split(r'(-|\s)', vulnerability)
        new_parts = [str(int(part)) if part.isdigit() else part for part in parts]
        processed_vulnerability = ''.join(new_parts)
        if processed_vulnerability.startswith('CVE '):
            processed_vulnerabilities.add(re.sub(__cve_pattern, rewrite_cve, processed_vulnerability).upper())
        elif processed_vulnerability.startswith('CWE '):
            processed_vulnerabilities.add(re.sub(__cwe_pattern, rewrite_cwe, processed_vulnerability).upper())
    return processed_vulnerabilities


def rewrite_cve(match):
        parts = match.group().split('-')
        if len(parts) == 3 and parts[1].isdigit() and parts[2].isdigit():
            return f"CVE-{int(parts[1]):04d}-{int(parts[2])}"
        elif len(parts) == 4 and parts[2].isdigit() and parts[3].isdigit():
            return f"CVE-{int(parts[2]):04d}-{int(parts[3])}"
        return match.group()
    

def rewrite_cwe(match):
    parts = match.group().split(' ')
    if len(parts) == 2 and parts[1].isdigit():
        return f"CWE-{int(parts[1])}"
    elif len(parts) == 3 and parts[2].isdigit():
        return f"CWE-{int(parts[2])}"
    return match.group()
