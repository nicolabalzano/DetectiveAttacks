from src.dataAccesAPI.objectsAPI.myStixAPI.AssetAPI import get_asset_from_ass_rel_dict
from src.dataAccesAPI.objectsAPI.myStixAPI.CampaignAPI import get_campaign_from_camp_rel_dict
from src.dataAccesAPI.objectsAPI.myStixAPI.ToolMalwareAPI import get_tool_malware_from_tw_rel_dict
from src.dataAccesAPI.objectsAPI.util import format_list_of_string, remove_empty_values, format_kill_chain_phases, \
    format_mitre_kill_chain_phases, format_external_references, check_if_all_values_in_dict_list_are_empty
from src.dataProvider.container import AttackPatternsContainer, ToolsMalwareContainer, CampaignsContainer, AssetsContainer
from src.dataProvider.domain.AttackPhase import AttackPhase


def get_attack_patter_from_mitre_id(mitre_id: str):
    """
    Get the attack pattern object from the mitre id
    :param mitre_id: the mitre id
    :return: the MyAttackPattern object
    """

    dict_at = {}
    at = AttackPatternsContainer().get_object_from_data_by_mitre_id(mitre_id)
    dict_at['ID'] = at.x_mitre_id
    dict_at['Name'] = at.name
    dict_at['Type'] = at.type
    dict_at['Description'] = at.description
    dict_at['Domains'] = format_list_of_string(at.x_mitre_domains)
    dict_at['Kill Chain phases'] = format_list_of_string(format_kill_chain_phases(at))
    dict_at['Mitre Kill Chain phases'] = format_mitre_kill_chain_phases(at.kill_chain_phases)
    dict_at['Platforms'] = format_list_of_string(at.x_mitre_platforms)
    dict_at['Detection suggestions'] = at.x_mitre_detection
    dict_at['Mitigations'] = [
        {
            'ID': coa.x_mitre_id,
            'Name': coa.name,
            'Description': coa.description,
            'Type': coa.type,
            'Purpose': rel.relationship_type,
            'Suggestion for this case': rel.description,
            'External references': format_external_references(coa.external_references),
        } for coa, rel in at.courses_of_action_and_relationship.items()
    ]

    dict_at['Procedure examples'] = get_tool_malware_from_tw_rel_dict(
        ToolsMalwareContainer().get_objects_related_by_attack_pattern_id(at.id))
    dict_at['Campaigns that exploit this attack pattern'] = get_campaign_from_camp_rel_dict(
        CampaignsContainer().get_objects_related_by_attack_pattern_id(at.id))
    dict_at['Targeted assets'] = get_asset_from_ass_rel_dict(
        AssetsContainer().get_objects_related_by_attack_pattern_id(at.id))

    dict_at['Permission requirements'] = format_list_of_string(at.x_mitre_permissions_required)
    dict_at['Effective permissions'] = format_list_of_string(at.x_mitre_effective_permissions)
    dict_at['System requirements'] = format_list_of_string(at.x_mitre_system_requirements)
    dict_at['Network requirements'] = format_list_of_string(at.x_mitre_network_requirements)
    dict_at['Impact type'] = format_list_of_string(at.x_mitre_impact_type)
    dict_at['Data Source'] = format_list_of_string(at.x_mitre_data_sources)
    dict_at['Defense Bypassed'] = format_list_of_string(at.x_mitre_defense_bypassed)
    dict_at['Mitre version'] = format_list_of_string(at.x_mitre_version)
    dict_at['Deprecated'] = format_list_of_string(at.x_mitre_deprecated)
    dict_at['Revoked'] = format_list_of_string(at.revoked)
    dict_at['Is a sub-technique'] = at.x_mitre_is_subtechnique
    dict_at['Remote support'] = format_list_of_string(at.x_mitre_remote_support)
    dict_at['Tactic type'] = format_list_of_string(at.x_mitre_tactic_type)
    dict_at['External references'] = format_external_references(at.external_references)
    
    dict_at.update(get_keys_values_of_realated_attck_patterns([at.x_mitre_id]))

    return remove_empty_values(dict_at)


def get_all_attack_patterns_grouped_by_CKCP():
    """
    Get all attack patterns grouped by CKC phases
    :return: dict of {CKC_phase: [attack_pattern]}
    """
    return {
            phase: [
                {
                    'Name': at.name,
                    'ID': at.x_mitre_id,
                    'Domains': format_list_of_string(at.x_mitre_domains),
                    'Platforms': format_list_of_string(at.x_mitre_platforms),
                }
                for at in ats
            ]
            for phase, ats in AttackPatternsContainer().get_attack_patterns_grouped_by_CKCPhase().items()
        }


def get_all_platforms():
    """
    Get all platforms
    :return: list of platforms
    """
    return AttackPatternsContainer().get_all_platforms()


def __get_futured_attack_patterns_rel(at):
    return  __get_related_attacks(AttackPatternsContainer().get_futured_attack_patterns_grouped_by_CKCPhase, at)


def __get_past_attack_patterns_rel(at):
    return __get_related_attacks(AttackPatternsContainer().get_probably_happened_attack_patterns_grouped_by_CKCPhase,at)


def __get_all_attack_patterns_rel(at):
    return __get_related_attacks(AttackPatternsContainer().get_all_related_attack_patterns_grouped_by_CKCPhase, at)


def get_keys_values_of_realated_attck_patterns(attack_pattern_ids: str):
    """
    This function gets the keys and values of the related attack patterns 
    
    Args:
        attack_pattern_ids (str): id of the attack patterns
        
    Returns:
        dict: dictionary with the keys and values of the related attack patterns
    """
    dict_ = {'Attack patterns that can lead to this': {},
             'Attack patterns that may occur after this': {},
             'All related attack patterns that you can encounter': {}}

    for attack_pattern_id in attack_pattern_ids:
        dict_['Attack patterns that can lead to this'].update(
            __get_past_attack_patterns_rel(AttackPatternsContainer().get_object_from_data_by_mitre_id(attack_pattern_id)))
        dict_['Attack patterns that may occur after this'].update(
            __get_futured_attack_patterns_rel(AttackPatternsContainer().get_object_from_data_by_mitre_id(attack_pattern_id)))
        dict_['All related attack patterns that you can encounter'].update(
            __get_all_attack_patterns_rel(AttackPatternsContainer().get_object_from_data_by_mitre_id(attack_pattern_id)))

    if len(attack_pattern_ids) > 1:
        dict_['Attack patterns that can lead to this'] = __collapse_duplicate_attack_patterns(dict_['Attack patterns that can lead to this'])
        dict_['Attack patterns that may occur after this'] = __collapse_duplicate_attack_patterns(dict_['Attack patterns that may occur after this'])
        dict_['All related attack patterns that you can encounter'] = __collapse_duplicate_attack_patterns(dict_['All related attack patterns that you can encounter'])
        
    return dict_

def __collapse_duplicate_attack_patterns(phases_attack_patterns):
    """
    This function removes the duplicate attack patterns in a list of dictionaries
    
    Args:
        attack_patterns (list): list of dict of attack patterns and relationships by phases
        
    Returns:
        list: list of dict of attack patterns and relationships by phases without duplicates
    """
    unique_attack_patterns_by_phases = {}
    unique_ids = {}

    for phase, ats in phases_attack_patterns.items():
        
        if phase not in unique_attack_patterns_by_phases:
            unique_attack_patterns_by_phases.update({ phase: [] })
        if phase not in unique_ids:
            unique_ids.update({ phase: set() })
        
        for attack_pattern in ats:
            if attack_pattern['ID'] not in unique_ids[phase]:
                unique_attack_patterns_by_phases[phase].append(attack_pattern)
                unique_ids[phase].add(attack_pattern['ID'])
            else:
                first_attack_patterns = [ap for ap in ats if ap['ID'] == attack_pattern['ID']][0]
                first_attack_patterns['Relationship Source ID'].extend(attack_pattern['Relationship Source ID'])
                first_attack_patterns['Relationship type'].extend(attack_pattern['Relationship type'])
        

    return unique_attack_patterns_by_phases 


def __get_related_attacks(function_futured_past_or_all, attack_pattern):
    attack_data = function_futured_past_or_all(attack_pattern)
        
    formatted_attack_patterns_by_phases = {}
    
    for phase, related_ats in attack_data.items():
        phase_data = []
        for at, rel in related_ats.items():

            source_relationship = __get_source_relationships(rel.source_ref)
                        
            phase_data.append({
                'Name': f'"{at.name}" from {source_relationship.type} "{source_relationship.name}" for {rel.relationship_type}',
                'Description': rel.description,
                'ID': at.x_mitre_id,
                'Attack pattern name': at.name,
                'Relationship Source ID': [source_relationship.x_mitre_id],
                'Relationship type': [rel.relationship_type],
            })
        formatted_attack_patterns_by_phases[phase] = phase_data
    
    
    # Order the dictionary by the CKC phases
    formatted_attack_patterns_by_phases_ordered = {k: formatted_attack_patterns_by_phases[k] if k in formatted_attack_patterns_by_phases else [] for k in AttackPhase.get_CKC_mapping_to_phases().keys()}
        
    return formatted_attack_patterns_by_phases_ordered


def __get_source_relationships(source_id: str):
    containers = [
        AttackPatternsContainer(),
        CampaignsContainer(),
        ToolsMalwareContainer(),
        AssetsContainer(),
    ]

    for container in containers:
        obj = container.get_object_from_data_by_id(source_id)
        if obj:
            return obj
    return None
